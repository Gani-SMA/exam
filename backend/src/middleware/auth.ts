import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport { User, IUser } from '../models/User';\nimport { logger } from '../utils/logger';\nimport { cacheService } from '../config/redis';\n\n// Extend Request interface to include user\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: IUser;\n      userId?: string;\n    }\n  }\n}\n\ninterface JWTPayload {\n  userId: string;\n  email: string;\n  role: string;\n  iat: number;\n  exp: number;\n}\n\n// Authentication middleware\nexport const authenticate = async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const authHeader = req.header('Authorization');\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_TOKEN_MISSING',\n          message: 'Access token is required'\n        }\n      });\n    }\n\n    const token = authHeader.substring(7); // Remove 'Bearer ' prefix\n    \n    if (!token) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_TOKEN_INVALID',\n          message: 'Invalid token format'\n        }\n      });\n    }\n\n    // Check if token is blacklisted\n    const isBlacklisted = await cacheService.exists(`blacklist:${token}`);\n    if (isBlacklisted) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_TOKEN_BLACKLISTED',\n          message: 'Token has been revoked'\n        }\n      });\n    }\n\n    // Verify JWT token\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;\n    \n    // Check if user exists in cache first\n    let user: IUser | null = null;\n    const cachedUser = await cacheService.get(`user:${decoded.userId}`);\n    \n    if (cachedUser) {\n      user = JSON.parse(cachedUser);\n    } else {\n      // Fetch user from database\n      user = await User.findById(decoded.userId).select('-password');\n      \n      if (user) {\n        // Cache user for 15 minutes\n        await cacheService.set(`user:${decoded.userId}`, JSON.stringify(user), 900);\n      }\n    }\n\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_USER_NOT_FOUND',\n          message: 'User not found'\n        }\n      });\n    }\n\n    // Check if user account is active\n    if (!user.isEmailVerified) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_EMAIL_NOT_VERIFIED',\n          message: 'Please verify your email address'\n        }\n      });\n    }\n\n    // Attach user to request\n    req.user = user;\n    req.userId = user._id.toString();\n    \n    // Update last activity\n    user.lastActivity = new Date();\n    await user.save();\n    \n    logger.info('User authenticated successfully', {\n      userId: user._id,\n      email: user.email,\n      role: user.role,\n      ip: req.ip\n    });\n\n    next();\n  } catch (error) {\n    if (error instanceof jwt.JsonWebTokenError) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_TOKEN_INVALID',\n          message: 'Invalid token'\n        }\n      });\n    }\n    \n    if (error instanceof jwt.TokenExpiredError) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_TOKEN_EXPIRED',\n          message: 'Token has expired'\n        }\n      });\n    }\n\n    logger.error('Authentication error:', error);\n    return res.status(500).json({\n      success: false,\n      error: {\n        code: 'AUTH_INTERNAL_ERROR',\n        message: 'Authentication failed'\n      }\n    });\n  }\n};\n\n// Optional authentication middleware (doesn't fail if no token)\nexport const optionalAuth = async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const authHeader = req.header('Authorization');\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return next(); // Continue without authentication\n    }\n\n    const token = authHeader.substring(7);\n    \n    if (!token) {\n      return next(); // Continue without authentication\n    }\n\n    // Check if token is blacklisted\n    const isBlacklisted = await cacheService.exists(`blacklist:${token}`);\n    if (isBlacklisted) {\n      return next(); // Continue without authentication\n    }\n\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;\n    const user = await User.findById(decoded.userId).select('-password');\n    \n    if (user && user.isEmailVerified) {\n      req.user = user;\n      req.userId = user._id.toString();\n    }\n\n    next();\n  } catch (error) {\n    // Silently continue without authentication on error\n    next();\n  }\n};\n\n// Role-based authorization middleware\nexport const authorize = (...roles: string[]) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_REQUIRED',\n          message: 'Authentication required'\n        }\n      });\n    }\n\n    if (!roles.includes(req.user.role)) {\n      logger.warn('Authorization failed', {\n        userId: req.user._id,\n        userRole: req.user.role,\n        requiredRoles: roles,\n        endpoint: req.originalUrl\n      });\n      \n      return res.status(403).json({\n        success: false,\n        error: {\n          code: 'AUTH_INSUFFICIENT_PERMISSIONS',\n          message: 'Insufficient permissions'\n        }\n      });\n    }\n\n    next();\n  };\n};\n\n// Check if user owns resource or has admin role\nexport const authorizeOwnerOrAdmin = (resourceUserIdField: string = 'userId') => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_REQUIRED',\n          message: 'Authentication required'\n        }\n      });\n    }\n\n    const resourceUserId = req.params[resourceUserIdField] || req.body[resourceUserIdField];\n    const isOwner = req.user._id.toString() === resourceUserId;\n    const isAdmin = req.user.role === 'admin';\n\n    if (!isOwner && !isAdmin) {\n      return res.status(403).json({\n        success: false,\n        error: {\n          code: 'AUTH_RESOURCE_ACCESS_DENIED',\n          message: 'Access denied to this resource'\n        }\n      });\n    }\n\n    next();\n  };\n};\n\n// Middleware to check if user can take exam\nexport const canTakeExam = async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_REQUIRED',\n          message: 'Authentication required'\n        }\n      });\n    }\n\n    const examId = req.params.examId || req.body.examId;\n    \n    if (!examId) {\n      return res.status(400).json({\n        success: false,\n        error: {\n          code: 'EXAM_ID_REQUIRED',\n          message: 'Exam ID is required'\n        }\n      });\n    }\n\n    // Check if user has reached maximum attempts (this would need exam data)\n    // This is a placeholder - actual implementation would check ExamSession collection\n    \n    next();\n  } catch (error) {\n    logger.error('Exam authorization error:', error);\n    return res.status(500).json({\n      success: false,\n      error: {\n        code: 'AUTH_EXAM_CHECK_FAILED',\n        message: 'Failed to verify exam access'\n      }\n    });\n  }\n};\n\n// Middleware to validate API key for external integrations\nexport const validateApiKey = async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const apiKey = req.header('X-API-Key');\n    \n    if (!apiKey) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'API_KEY_MISSING',\n          message: 'API key is required'\n        }\n      });\n    }\n\n    // Validate API key (this would check against a database of valid keys)\n    const isValidKey = apiKey === process.env.INTERNAL_API_KEY;\n    \n    if (!isValidKey) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'API_KEY_INVALID',\n          message: 'Invalid API key'\n        }\n      });\n    }\n\n    next();\n  } catch (error) {\n    logger.error('API key validation error:', error);\n    return res.status(500).json({\n      success: false,\n      error: {\n        code: 'API_KEY_VALIDATION_FAILED',\n        message: 'API key validation failed'\n      }\n    });\n  }\n};\n\n// Middleware to check subscription status\nexport const checkSubscription = (requiredPlan: string[] = ['premium', 'pro']) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTH_REQUIRED',\n          message: 'Authentication required'\n        }\n      });\n    }\n\n    const userPlan = req.user.subscription?.plan || 'free';\n    const isActive = req.user.subscription?.status === 'active';\n    \n    if (!requiredPlan.includes(userPlan) || !isActive) {\n      return res.status(403).json({\n        success: false,\n        error: {\n          code: 'SUBSCRIPTION_REQUIRED',\n          message: `This feature requires a ${requiredPlan.join(' or ')} subscription`,\n          details: {\n            currentPlan: userPlan,\n            requiredPlans: requiredPlan\n          }\n        }\n      });\n    }\n\n    next();\n  };\n};\n\n// Rate limiting per user\nexport const userRateLimit = (maxRequests: number, windowMs: number) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return next(); // Skip rate limiting for unauthenticated users\n    }\n\n    const key = `rate_limit:user:${req.user._id}:${req.route?.path || req.path}`;\n    const current = await cacheService.get(key);\n    \n    if (current && parseInt(current) >= maxRequests) {\n      return res.status(429).json({\n        success: false,\n        error: {\n          code: 'RATE_LIMIT_EXCEEDED',\n          message: 'Too many requests, please try again later',\n          retryAfter: Math.ceil(windowMs / 1000)\n        }\n      });\n    }\n\n    // Increment counter\n    const newCount = current ? parseInt(current) + 1 : 1;\n    await cacheService.set(key, newCount.toString(), Math.ceil(windowMs / 1000));\n    \n    next();\n  };\n};"
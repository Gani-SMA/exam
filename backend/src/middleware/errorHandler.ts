import { Request, Response, NextFunction } from 'express';\nimport { logger } from '../utils/logger';\nimport mongoose from 'mongoose';\nimport { ValidationError } from 'express-validator';\n\n// Custom error class\nexport class AppError extends Error {\n  public statusCode: number;\n  public status: string;\n  public isOperational: boolean;\n  public code?: string;\n  public details?: any;\n\n  constructor(\n    message: string,\n    statusCode: number = 500,\n    code?: string,\n    details?: any\n  ) {\n    super(message);\n    \n    this.statusCode = statusCode;\n    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';\n    this.isOperational = true;\n    this.code = code;\n    this.details = details;\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n// Error response interface\ninterface ErrorResponse {\n  success: false;\n  error: {\n    code: string;\n    message: string;\n    details?: any;\n    timestamp: string;\n    requestId: string;\n    stack?: string;\n  };\n}\n\n// Generate unique request ID\nconst generateRequestId = (): string => {\n  return Math.random().toString(36).substring(2, 15) + \n         Math.random().toString(36).substring(2, 15);\n};\n\n// Handle MongoDB cast errors\nconst handleCastErrorDB = (err: mongoose.Error.CastError): AppError => {\n  const message = `Invalid ${err.path}: ${err.value}`;\n  return new AppError(message, 400, 'INVALID_ID');\n};\n\n// Handle MongoDB duplicate field errors\nconst handleDuplicateFieldsDB = (err: any): AppError => {\n  const field = Object.keys(err.keyValue)[0];\n  const value = err.keyValue[field];\n  const message = `${field.charAt(0).toUpperCase() + field.slice(1)} '${value}' already exists`;\n  return new AppError(message, 400, 'DUPLICATE_FIELD', { field, value });\n};\n\n// Handle MongoDB validation errors\nconst handleValidationErrorDB = (err: mongoose.Error.ValidationError): AppError => {\n  const errors = Object.values(err.errors).map(el => el.message);\n  const message = `Invalid input data: ${errors.join('. ')}`;\n  return new AppError(message, 400, 'VALIDATION_ERROR', { errors });\n};\n\n// Handle JWT errors\nconst handleJWTError = (): AppError => {\n  return new AppError('Invalid token. Please log in again!', 401, 'INVALID_TOKEN');\n};\n\nconst handleJWTExpiredError = (): AppError => {\n  return new AppError('Your token has expired! Please log in again.', 401, 'EXPIRED_TOKEN');\n};\n\n// Handle express-validator errors\nconst handleValidationErrors = (errors: ValidationError[]): AppError => {\n  const formattedErrors = errors.map(error => ({\n    field: error.param,\n    message: error.msg,\n    value: error.value\n  }));\n  \n  return new AppError(\n    'Validation failed',\n    400,\n    'VALIDATION_FAILED',\n    { errors: formattedErrors }\n  );\n};\n\n// Send error response in development\nconst sendErrorDev = (err: AppError, req: Request, res: Response): void => {\n  const requestId = generateRequestId();\n  \n  logger.error('Development Error', {\n    requestId,\n    error: err,\n    stack: err.stack,\n    url: req.originalUrl,\n    method: req.method,\n    ip: req.ip,\n    userAgent: req.get('User-Agent')\n  });\n\n  const errorResponse: ErrorResponse = {\n    success: false,\n    error: {\n      code: err.code || 'INTERNAL_ERROR',\n      message: err.message,\n      details: err.details,\n      timestamp: new Date().toISOString(),\n      requestId,\n      stack: err.stack\n    }\n  };\n\n  res.status(err.statusCode).json(errorResponse);\n};\n\n// Send error response in production\nconst sendErrorProd = (err: AppError, req: Request, res: Response): void => {\n  const requestId = generateRequestId();\n  \n  // Log error details for internal tracking\n  logger.error('Production Error', {\n    requestId,\n    message: err.message,\n    statusCode: err.statusCode,\n    code: err.code,\n    url: req.originalUrl,\n    method: req.method,\n    ip: req.ip,\n    userId: req.user?._id,\n    userAgent: req.get('User-Agent'),\n    stack: err.isOperational ? undefined : err.stack\n  });\n\n  // Operational, trusted error: send message to client\n  if (err.isOperational) {\n    const errorResponse: ErrorResponse = {\n      success: false,\n      error: {\n        code: err.code || 'OPERATIONAL_ERROR',\n        message: err.message,\n        details: err.details,\n        timestamp: new Date().toISOString(),\n        requestId\n      }\n    };\n\n    res.status(err.statusCode).json(errorResponse);\n  } else {\n    // Programming or other unknown error: don't leak error details\n    const errorResponse: ErrorResponse = {\n      success: false,\n      error: {\n        code: 'INTERNAL_SERVER_ERROR',\n        message: 'Something went wrong!',\n        timestamp: new Date().toISOString(),\n        requestId\n      }\n    };\n\n    res.status(500).json(errorResponse);\n  }\n};\n\n// Global error handling middleware\nexport const errorHandler = (\n  err: any,\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void => {\n  let error = { ...err };\n  error.message = err.message;\n\n  // Handle specific error types\n  if (err.name === 'CastError') {\n    error = handleCastErrorDB(err);\n  }\n  \n  if (err.code === 11000) {\n    error = handleDuplicateFieldsDB(err);\n  }\n  \n  if (err.name === 'ValidationError') {\n    error = handleValidationErrorDB(err);\n  }\n  \n  if (err.name === 'JsonWebTokenError') {\n    error = handleJWTError();\n  }\n  \n  if (err.name === 'TokenExpiredError') {\n    error = handleJWTExpiredError();\n  }\n\n  // Handle express-validator errors\n  if (Array.isArray(err) && err.length > 0 && err[0].msg) {\n    error = handleValidationErrors(err);\n  }\n\n  // Ensure error has required properties\n  if (!error.statusCode) {\n    error.statusCode = 500;\n  }\n  \n  if (!error.isOperational) {\n    error.isOperational = false;\n  }\n\n  // Send appropriate error response\n  if (process.env.NODE_ENV === 'development') {\n    sendErrorDev(error, req, res);\n  } else {\n    sendErrorProd(error, req, res);\n  }\n};\n\n// Async error wrapper\nexport const catchAsync = (fn: Function) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    fn(req, res, next).catch(next);\n  };\n};\n\n// Handle unhandled promise rejections\nprocess.on('unhandledRejection', (err: Error) => {\n  logger.error('UNHANDLED PROMISE REJECTION! ðŸ’¥ Shutting down...', {\n    name: err.name,\n    message: err.message,\n    stack: err.stack\n  });\n  \n  process.exit(1);\n});\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (err: Error) => {\n  logger.error('UNCAUGHT EXCEPTION! ðŸ’¥ Shutting down...', {\n    name: err.name,\n    message: err.message,\n    stack: err.stack\n  });\n  \n  process.exit(1);\n});\n\n// Validation middleware for express-validator\nexport const validateRequest = (req: Request, res: Response, next: NextFunction) => {\n  const { validationResult } = require('express-validator');\n  const errors = validationResult(req);\n  \n  if (!errors.isEmpty()) {\n    const error = handleValidationErrors(errors.array());\n    return next(error);\n  }\n  \n  next();\n};\n\n// Rate limit error handler\nexport const handleRateLimitError = (req: Request, res: Response) => {\n  const requestId = generateRequestId();\n  \n  logger.warn('Rate limit exceeded', {\n    requestId,\n    ip: req.ip,\n    url: req.originalUrl,\n    method: req.method,\n    userAgent: req.get('User-Agent'),\n    userId: req.user?._id\n  });\n\n  const errorResponse: ErrorResponse = {\n    success: false,\n    error: {\n      code: 'RATE_LIMIT_EXCEEDED',\n      message: 'Too many requests from this IP, please try again later.',\n      timestamp: new Date().toISOString(),\n      requestId,\n      details: {\n        retryAfter: '15 minutes'\n      }\n    }\n  };\n\n  res.status(429).json(errorResponse);\n};\n\n// 404 error handler\nexport const notFound = (req: Request, res: Response, next: NextFunction) => {\n  const error = new AppError(\n    `Can't find ${req.originalUrl} on this server!`,\n    404,\n    'ROUTE_NOT_FOUND',\n    {\n      method: req.method,\n      url: req.originalUrl\n    }\n  );\n  \n  next(error);\n};\n\n// Security error handlers\nexport const handleSecurityError = (type: string, req: Request, res: Response) => {\n  const requestId = generateRequestId();\n  \n  logger.warn('Security violation detected', {\n    requestId,\n    type,\n    ip: req.ip,\n    url: req.originalUrl,\n    method: req.method,\n    userAgent: req.get('User-Agent'),\n    userId: req.user?._id\n  });\n\n  const errorResponse: ErrorResponse = {\n    success: false,\n    error: {\n      code: 'SECURITY_VIOLATION',\n      message: 'Security violation detected',\n      timestamp: new Date().toISOString(),\n      requestId\n    }\n  };\n\n  res.status(403).json(errorResponse);\n};\n\n// Database connection error handler\nexport const handleDatabaseError = (err: Error) => {\n  logger.error('Database connection error', {\n    name: err.name,\n    message: err.message,\n    stack: err.stack\n  });\n  \n  // Implement reconnection logic or graceful shutdown\n};\n\n// Export error types for use in other modules\nexport { AppError };"
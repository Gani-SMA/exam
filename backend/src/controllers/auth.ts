import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport crypto from 'crypto';\nimport { User, IUser } from '../models/User';\nimport { AppError, catchAsync } from '../middleware/errorHandler';\nimport { logger } from '../utils/logger';\nimport { cacheService } from '../config/redis';\nimport { sendEmail } from '../utils/email';\nimport { validationResult } from 'express-validator';\n\n// JWT token generation\nconst generateToken = (userId: string, email: string, role: string): string => {\n  return jwt.sign(\n    { userId, email, role },\n    process.env.JWT_SECRET!,\n    { expiresIn: process.env.JWT_EXPIRE || '7d' }\n  );\n};\n\nconst generateRefreshToken = (userId: string): string => {\n  return jwt.sign(\n    { userId, type: 'refresh' },\n    process.env.JWT_REFRESH_SECRET!,\n    { expiresIn: process.env.JWT_REFRESH_EXPIRE || '30d' }\n  );\n};\n\n// Send token response\nconst sendTokenResponse = async (\n  user: IUser,\n  statusCode: number,\n  res: Response,\n  message: string = 'Success'\n) => {\n  const token = generateToken(user._id.toString(), user.email, user.role);\n  const refreshToken = generateRefreshToken(user._id.toString());\n  \n  // Store refresh token in Redis with expiration\n  await cacheService.set(\n    `refresh_token:${user._id}`,\n    refreshToken,\n    30 * 24 * 60 * 60 // 30 days in seconds\n  );\n  \n  // Update user's last login\n  user.lastLogin = new Date();\n  await user.save();\n  \n  // Remove password from output\n  const userResponse = {\n    _id: user._id,\n    firstName: user.firstName,\n    lastName: user.lastName,\n    email: user.email,\n    role: user.role,\n    avatar: user.avatar,\n    isEmailVerified: user.isEmailVerified,\n    gamification: user.gamification,\n    statistics: user.statistics,\n    settings: user.settings,\n    subscription: user.subscription,\n    createdAt: user.createdAt\n  };\n  \n  res.status(statusCode).json({\n    success: true,\n    message,\n    data: {\n      user: userResponse,\n      token,\n      refreshToken,\n      expiresIn: process.env.JWT_EXPIRE || '7d'\n    }\n  });\n};\n\n/**\n * @desc    Register user\n * @route   POST /api/auth/register\n * @access  Public\n */\nexport const register = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  // Check validation errors\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return next(new AppError('Validation failed', 400, 'VALIDATION_ERROR', errors.array()));\n  }\n  \n  const { firstName, lastName, email, password, role = 'student' } = req.body;\n  \n  // Create user\n  const user = await User.create({\n    firstName,\n    lastName,\n    email,\n    password,\n    role,\n    gamification: {\n      level: 1,\n      xp: 0,\n      totalXP: 0,\n      streak: {\n        current: 0,\n        longest: 0,\n        lastActivity: new Date()\n      },\n      achievements: [],\n      badges: []\n    },\n    statistics: {\n      totalExamsTaken: 0,\n      totalQuestionsAnswered: 0,\n      totalStudyTime: 0,\n      averageScore: 0,\n      subjectWiseStats: []\n    },\n    settings: {\n      notifications: {\n        email: true,\n        push: true,\n        examReminders: true,\n        achievementAlerts: true,\n        weeklyReports: true\n      },\n      privacy: {\n        showInLeaderboard: true,\n        shareProgress: true,\n        allowFriendRequests: true\n      },\n      preferences: {\n        theme: 'light',\n        language: 'en',\n        timezone: 'UTC',\n        soundEffects: true,\n        volume: 50\n      }\n    },\n    examPreferences: {\n      preferredExamTypes: [],\n      studyGoals: []\n    }\n  });\n  \n  // Generate email verification token\n  const verificationToken = user.generateEmailVerificationToken();\n  await user.save();\n  \n  // Send verification email\n  try {\n    await sendEmail({\n      to: user.email,\n      subject: 'Email Verification - Examination Platform',\n      template: 'emailVerification',\n      data: {\n        firstName: user.firstName,\n        verificationToken,\n        verificationUrl: `${process.env.FRONTEND_URL}/verify-email?token=${verificationToken}`\n      }\n    });\n  } catch (error) {\n    logger.error('Failed to send verification email:', error);\n    // Don't fail registration if email fails\n  }\n  \n  logger.info('User registered successfully', {\n    userId: user._id,\n    email: user.email,\n    role: user.role\n  });\n  \n  res.status(201).json({\n    success: true,\n    message: 'Registration successful. Please check your email to verify your account.',\n    data: {\n      userId: user._id,\n      email: user.email,\n      emailSent: true\n    }\n  });\n});\n\n/**\n * @desc    Login user\n * @route   POST /api/auth/login\n * @access  Public\n */\nexport const login = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return next(new AppError('Validation failed', 400, 'VALIDATION_ERROR', errors.array()));\n  }\n  \n  const { email, password } = req.body;\n  \n  // Find user and include password for comparison\n  const user = await User.findOne({ email }).select('+password');\n  \n  if (!user || !(await user.comparePassword(password))) {\n    return next(new AppError('Invalid email or password', 401, 'INVALID_CREDENTIALS'));\n  }\n  \n  if (!user.isEmailVerified) {\n    return next(new AppError('Please verify your email address before logging in', 401, 'EMAIL_NOT_VERIFIED'));\n  }\n  \n  logger.info('User logged in successfully', {\n    userId: user._id,\n    email: user.email,\n    ip: req.ip\n  });\n  \n  await sendTokenResponse(user, 200, res, 'Login successful');\n});\n\n/**\n * @desc    Logout user\n * @route   POST /api/auth/logout\n * @access  Private\n */\nexport const logout = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const authHeader = req.header('Authorization');\n  const token = authHeader?.substring(7); // Remove 'Bearer ' prefix\n  \n  if (token) {\n    // Add token to blacklist\n    const decoded = jwt.decode(token) as any;\n    const expiresIn = decoded.exp - Math.floor(Date.now() / 1000);\n    \n    if (expiresIn > 0) {\n      await cacheService.set(`blacklist:${token}`, 'true', expiresIn);\n    }\n  }\n  \n  // Remove refresh token\n  if (req.user) {\n    await cacheService.del(`refresh_token:${req.user._id}`);\n  }\n  \n  logger.info('User logged out', {\n    userId: req.user?._id,\n    ip: req.ip\n  });\n  \n  res.status(200).json({\n    success: true,\n    message: 'Logged out successfully'\n  });\n});\n\n/**\n * @desc    Refresh access token\n * @route   POST /api/auth/refresh\n * @access  Public\n */\nexport const refreshToken = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const { refreshToken } = req.body;\n  \n  if (!refreshToken) {\n    return next(new AppError('Refresh token is required', 400, 'REFRESH_TOKEN_MISSING'));\n  }\n  \n  try {\n    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET!) as any;\n    \n    if (decoded.type !== 'refresh') {\n      return next(new AppError('Invalid token type', 401, 'INVALID_TOKEN_TYPE'));\n    }\n    \n    // Check if refresh token exists in Redis\n    const storedToken = await cacheService.get(`refresh_token:${decoded.userId}`);\n    \n    if (!storedToken || storedToken !== refreshToken) {\n      return next(new AppError('Invalid refresh token', 401, 'INVALID_REFRESH_TOKEN'));\n    }\n    \n    // Find user\n    const user = await User.findById(decoded.userId);\n    \n    if (!user) {\n      return next(new AppError('User not found', 404, 'USER_NOT_FOUND'));\n    }\n    \n    // Generate new tokens\n    const newToken = generateToken(user._id.toString(), user.email, user.role);\n    const newRefreshToken = generateRefreshToken(user._id.toString());\n    \n    // Update refresh token in Redis\n    await cacheService.set(\n      `refresh_token:${user._id}`,\n      newRefreshToken,\n      30 * 24 * 60 * 60 // 30 days\n    );\n    \n    res.status(200).json({\n      success: true,\n      message: 'Token refreshed successfully',\n      data: {\n        token: newToken,\n        refreshToken: newRefreshToken,\n        expiresIn: process.env.JWT_EXPIRE || '7d'\n      }\n    });\n  } catch (error) {\n    return next(new AppError('Invalid refresh token', 401, 'INVALID_REFRESH_TOKEN'));\n  }\n});\n\n/**\n * @desc    Verify email\n * @route   POST /api/auth/verify-email\n * @access  Public\n */\nexport const verifyEmail = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const { token } = req.body;\n  \n  if (!token) {\n    return next(new AppError('Verification token is required', 400, 'TOKEN_MISSING'));\n  }\n  \n  // Hash the token\n  const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n  \n  // Find user with matching token\n  const user = await User.findOne({\n    emailVerificationToken: hashedToken,\n    isEmailVerified: false\n  });\n  \n  if (!user) {\n    return next(new AppError('Invalid or expired verification token', 400, 'INVALID_TOKEN'));\n  }\n  \n  // Verify email\n  user.isEmailVerified = true;\n  user.emailVerificationToken = undefined;\n  await user.save();\n  \n  logger.info('Email verified successfully', {\n    userId: user._id,\n    email: user.email\n  });\n  \n  res.status(200).json({\n    success: true,\n    message: 'Email verified successfully. You can now log in.'\n  });\n});\n\n/**\n * @desc    Forgot password\n * @route   POST /api/auth/forgot-password\n * @access  Public\n */\nexport const forgotPassword = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return next(new AppError('Validation failed', 400, 'VALIDATION_ERROR', errors.array()));\n  }\n  \n  const { email } = req.body;\n  \n  const user = await User.findOne({ email });\n  \n  if (!user) {\n    // Don't reveal if email exists or not\n    return res.status(200).json({\n      success: true,\n      message: 'If an account with that email exists, a password reset link has been sent.'\n    });\n  }\n  \n  // Generate reset token\n  const resetToken = user.generatePasswordResetToken();\n  await user.save();\n  \n  // Send reset email\n  try {\n    await sendEmail({\n      to: user.email,\n      subject: 'Password Reset - Examination Platform',\n      template: 'passwordReset',\n      data: {\n        firstName: user.firstName,\n        resetToken,\n        resetUrl: `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`,\n        expiresIn: '10 minutes'\n      }\n    });\n    \n    logger.info('Password reset email sent', {\n      userId: user._id,\n      email: user.email\n    });\n  } catch (error) {\n    user.passwordResetToken = undefined;\n    user.passwordResetExpires = undefined;\n    await user.save();\n    \n    logger.error('Failed to send password reset email:', error);\n    return next(new AppError('Failed to send password reset email', 500, 'EMAIL_SEND_FAILED'));\n  }\n  \n  res.status(200).json({\n    success: true,\n    message: 'If an account with that email exists, a password reset link has been sent.'\n  });\n});\n\n/**\n * @desc    Reset password\n * @route   POST /api/auth/reset-password\n * @access  Public\n */\nexport const resetPassword = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return next(new AppError('Validation failed', 400, 'VALIDATION_ERROR', errors.array()));\n  }\n  \n  const { token, password } = req.body;\n  \n  // Hash the token\n  const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\n  \n  // Find user with matching token and check expiration\n  const user = await User.findOne({\n    passwordResetToken: hashedToken,\n    passwordResetExpires: { $gt: Date.now() }\n  });\n  \n  if (!user) {\n    return next(new AppError('Invalid or expired reset token', 400, 'INVALID_RESET_TOKEN'));\n  }\n  \n  // Set new password\n  user.password = password;\n  user.passwordResetToken = undefined;\n  user.passwordResetExpires = undefined;\n  await user.save();\n  \n  logger.info('Password reset successfully', {\n    userId: user._id,\n    email: user.email\n  });\n  \n  await sendTokenResponse(user, 200, res, 'Password reset successful');\n});\n\n/**\n * @desc    Change password\n * @route   PUT /api/auth/change-password\n * @access  Private\n */\nexport const changePassword = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return next(new AppError('Validation failed', 400, 'VALIDATION_ERROR', errors.array()));\n  }\n  \n  const { currentPassword, newPassword } = req.body;\n  \n  // Get user with password\n  const user = await User.findById(req.user!._id).select('+password');\n  \n  if (!user) {\n    return next(new AppError('User not found', 404, 'USER_NOT_FOUND'));\n  }\n  \n  // Check current password\n  if (!(await user.comparePassword(currentPassword))) {\n    return next(new AppError('Current password is incorrect', 400, 'INCORRECT_PASSWORD'));\n  }\n  \n  // Set new password\n  user.password = newPassword;\n  await user.save();\n  \n  logger.info('Password changed successfully', {\n    userId: user._id,\n    email: user.email\n  });\n  \n  res.status(200).json({\n    success: true,\n    message: 'Password changed successfully'\n  });\n});\n\n/**\n * @desc    Get current user\n * @route   GET /api/auth/me\n * @access  Private\n */\nexport const getMe = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const user = await User.findById(req.user!._id)\n    .populate('gamification.achievements', 'name description icon color')\n    .populate('friends', 'firstName lastName avatar gamification.level')\n    .select('-password');\n  \n  if (!user) {\n    return next(new AppError('User not found', 404, 'USER_NOT_FOUND'));\n  }\n  \n  res.status(200).json({\n    success: true,\n    data: {\n      user\n    }\n  });\n});\n\n/**\n * @desc    Update user profile\n * @route   PUT /api/auth/profile\n * @access  Private\n */\nexport const updateProfile = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return next(new AppError('Validation failed', 400, 'VALIDATION_ERROR', errors.array()));\n  }\n  \n  const allowedFields = [\n    'firstName',\n    'lastName',\n    'phone',\n    'dateOfBirth',\n    'address',\n    'education',\n    'examPreferences',\n    'settings'\n  ];\n  \n  const updates: any = {};\n  \n  // Filter allowed fields\n  Object.keys(req.body).forEach(key => {\n    if (allowedFields.includes(key)) {\n      updates[key] = req.body[key];\n    }\n  });\n  \n  const user = await User.findByIdAndUpdate(\n    req.user!._id,\n    updates,\n    {\n      new: true,\n      runValidators: true\n    }\n  ).select('-password');\n  \n  if (!user) {\n    return next(new AppError('User not found', 404, 'USER_NOT_FOUND'));\n  }\n  \n  logger.info('Profile updated successfully', {\n    userId: user._id,\n    updatedFields: Object.keys(updates)\n  });\n  \n  res.status(200).json({\n    success: true,\n    message: 'Profile updated successfully',\n    data: {\n      user\n    }\n  });\n});\n\n/**\n * @desc    Delete account\n * @route   DELETE /api/auth/account\n * @access  Private\n */\nexport const deleteAccount = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  const { password } = req.body;\n  \n  if (!password) {\n    return next(new AppError('Password is required to delete account', 400, 'PASSWORD_REQUIRED'));\n  }\n  \n  // Get user with password\n  const user = await User.findById(req.user!._id).select('+password');\n  \n  if (!user) {\n    return next(new AppError('User not found', 404, 'USER_NOT_FOUND'));\n  }\n  \n  // Verify password\n  if (!(await user.comparePassword(password))) {\n    return next(new AppError('Incorrect password', 400, 'INCORRECT_PASSWORD'));\n  }\n  \n  // Delete user (this would also need to clean up related data)\n  await User.findByIdAndDelete(user._id);\n  \n  // Clean up Redis data\n  await cacheService.del(`user:${user._id}`);\n  await cacheService.del(`refresh_token:${user._id}`);\n  \n  logger.info('Account deleted', {\n    userId: user._id,\n    email: user.email\n  });\n  \n  res.status(200).json({\n    success: true,\n    message: 'Account deleted successfully'\n  });\n});"